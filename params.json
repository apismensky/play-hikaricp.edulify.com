{"name":"play-hikaricp","tagline":"HikariCP Plugin for Play 2.2.x and 2.3.x","body":"# HikariCP Plugin for 2.3.x\r\n\r\nThis plugin works with `2.3.x` of PlayFramework. It uses version `2.2.5` of HikariCP.\r\n\r\nNote, it can be made to work with Play `2.2.x` of the PlayFramework, but it requires changing the dependencies as\r\nthe current build relies on the Play `2.3.x` plugin.\r\n\r\n[![Build Status](https://travis-ci.org/edulify/play-hikaricp.edulify.com.svg?branch=master)](https://travis-ci.org/edulify/play-hikaricp.edulify.com)\r\n\r\n## Why HikariCP?\r\n\r\n[HikariCP](https://github.com/brettwooldridge/HikariCP) is supposed to be the fastest connection pool in Java land. But we did not start to use it because of speed, but because of its reliability. After suffering with connection leaks from BoneCP, we decide to implement our own database plugin to replace the default one. You can see [a discussion about database exceptions](https://groups.google.com/forum/#!topic/play-framework/7PBnjiXkNuU) caused by BoneCP (or misconfiguration of it). Also there are numerous other discussions about people having problems related to BoneCP.\r\n\r\nHere is how HikariCP is working for us:\r\n\r\n![HikariCP in Production](http://i.imgur.com/xPqkc7T.png)\r\n\r\n## Versions\r\n\r\n| Version | HikariCP | Play  | Comment                          |\r\n|--------:|---------:|------:|:---------------------------------|\r\n| 1.5.1   | 2.2.5    | 2.3.7 | Update to latest HikariCP/Play version |\r\n| 1.5.0   | 2.0.1    | 2.3.4 | Code cleanup and fail fast in case of misconfiguration |\r\n| 1.4.1   | 2.0.1    | 2.3.2 | Updates HikariCP, Scala and Play |\r\n| 1.4.0   | 1.4.0    | 2.3.1 | JNDI support and HikariCP 1.4.0  |\r\n| 1.3.1   | 1.3.8    | 2.3.1 | Corrects artifact name           |\r\n| 1.3.0   | 1.3.8    | 2.3.1 | Updates Play and Scala versions  |\r\n| 1.2.0   | 1.3.8    | 2.2.3 | Supports Heroku like services    |\r\n| 1.1.0   | 1.3.8    | 2.2.3 | Updates HikariCP and Play        |\r\n| 1.0.0   | 1.3.5    | 2.2.2 | First stable release             |\r\n\r\n## Repository\r\n\r\nYou need to add the following repository in order to use this module:\r\n\r\n```scala\r\nresolvers += Resolver.url(\"Edulify Repository\", url(\"http://edulify.github.io/modules/releases/\"))(Resolver.ivyStylePatterns)\r\n```\r\n\r\n## How to Use\r\n\r\nThere are just a few steps to properly configure the plugin. Just follow the steps bellow:\r\n\r\n### Step 1: Add dependencies\r\n\r\nAdd the following dependency to your `project/build.sbt` or `project/Build.scala`:\r\n\r\n    \"com.edulify\" %% \"play-hikaricp\" % \"1.5.1\"\r\n\r\n### Step 2: Disable default `dbplugin`\r\n\r\nAdd the following line to your `conf/application.conf`:\r\n\r\n    dbplugin=disabled\r\n\r\nThis will disable dbplugin and avoids that BoneCP creates useless connections (which in some cases can create database problems, like exhaust available connections).\r\n\r\n### Step 3: Enable HikariCP Plugin\r\n\r\nAdd the following line to your `conf/play.plugins`:\r\n\r\n    200:com.edulify.play.hikaricp.HikariCPPlugin\r\n\r\nDue to the fact that the [Play JPA plugin](https://github.com/playframework/playframework/blob/master/framework/src/play-java-jpa/src/main/resources/play.plugins) is assigned a priority of **400**, please make sure that you assign `com.edulify.play.hikaricp.HikariCPPlugin` a priority less than that when using datasources looked up via JNDI. Otherwise, during application startup when JPA attempts to create the `EntityManagerFactory` your datasource will not have been bound to JNDI yet. [Play documentation](http://playframework.com/documentation/2.3.x/ScalaPlugins) states that connection pools should use a **200** priority.\r\n\r\n### Step 4: Configure HikariCP\r\n\r\n##### Using `db.default.hikaricp.file`\r\n\r\n**This is the preferred way to configure HikariCP** because you have full access to all [properties documented here](https://github.com/brettwooldridge/HikariCP#configuration-knobs-baby) and you can also have specific configuration to development, test and production modes. You can create a specific hikari properties file and configure it using `db.default.hikaricp.file` in you `conf/application.conf` file.\r\n\r\nPer instance, if you have a `conf/production.conf` that is loaded by play in production mode, add the following line to this file:\r\n\r\n     db.default.hikaricp.file=\"conf/hikaricp.prod.properties\"\r\n\r\nOf course, you need to create `conf/hikaricp.dev.properties` file.\r\n\r\n##### Using `hikaricp.properties`\r\n\r\nJust create a `conf/hikaricp.properties` and the plugin will read it and create DataSource. **This mode has preference over using ordinary play way** because you have fine grained access to Hikari configuration.\r\n\r\n##### Using ordinary [Play way](http://www.playframework.com/documentation/2.2.x/SettingsJDBC)\r\n\r\nThe least recommended way. Configure database properties as stated in the Play docs. The table bellow shows how Play configurations are mapped to HikariCP:\r\n\r\nHikari                                          | Play                           | Defaults\r\n:-----------------------------------------------|:-------------------------------|:-----------\r\n`driverClassName`                               | `db.default.driver`            | * Must be provided\r\n`jdbcUrl`                                       | `db.default.url`               | * Must be provided\r\n`username`                                      | `db.default.user`              | * Must be provided\r\n`password`                                      | `db.default.password`          | * Must be provided\r\n -                                              | `db.default.partitionSize`     | * Unused/NA\r\n`maximumPoolSize` (partitionSize * maxPoolSize) | `db.default.maxPoolSize`       | 30\r\n`minimumPoolSize` (partitionSize * minPoolSize) | `db.default.minPoolSize`       | 5\r\n`maxLifetime`                                   | `db.default.maxConnectionAge`  | 30 min.\r\n`idleTimeout`                                   | `db.default.idleMaxAge`<br>`db.default.idleMaxAgeInMinutes`<br>`db.default.idleMaxAgeInSeconds`        | 10 min.\r\n`connectionTimeout`                             | `db.default.connectionTimeout`<br>`db.default.connectionTimeoutInMs`   | 30 sec.\r\n`leakDetectionThreshold`                        | `db.default.closeConnectionWatchTimeout`<br>`db.default.closeConnectionWatchTimeoutInMs`    | 0 ms\r\n`connectionInitSql`                             | `db.default.initSQL`           | -\r\n`connectionTestQuery`                           | `db.default.connectionTestStatement`           | -\r\n`autoCommit`                                    | `db.default.defaultAutoCommit` | `true`\r\n`transactionIsolation`                          | `db.default.defaultTransactionIsolation`  | -\r\n`readOnly`                                      | `db.default.defaultReadOnly`   | `false`\r\n`catalog`                                       | `db.default.defaultCatalog   ` | -\r\n`registerMbeans`                                | `db.default.statisticsEnabled` | `false`\r\n\r\n## JNDI Support\r\n\r\nThanks to community contribution, the plugin supports to bind a DataSource to a JNDI context. After properly configuring the plugin (as described above), just add the following configuration in you `application.conf`:\r\n\r\n     db.default.jndiName=\"DefaultDataSource\"\r\n\r\n## Deploying to Heroku\r\n\r\nWhen using Heroku, you need to [read the database url string](https://devcenter.heroku.com/articles/heroku-postgresql#connecting-in-java) from an environment variable called `DATABASE_JDBC_URL` because plain Java Properties does not offer a way to reference environment variables in a properties file. You will also need to create variables for username and password. To do this, run the following commands:\r\n\r\n      $ heroku config:set DATABASE_JDBC_URL=\"jdbc:postgresql://host:5432/dbname\"\r\n      $ heroku config:set DATABASE_USERNAME=username\r\n      $ heroku config:set DATABASE_PASSWORD=password\r\n\r\nYou can obtain the correct values for `host`, `dbname`, `username`, and `password` from the `DATABASE_URL` environment variable, which Heroku creates for you.  Then we use [Commons Configuration](http://commons.apache.org/proper/commons-configuration/) to read the `hikaricp.properties` file or the one configured by `db.default.hikaricp.file`.\r\n\r\nHere is an example:\r\n\r\n```\r\njdbcUrl=${env:DATABASE_JDBC_URL}\r\ndriverClassName=org.postgresql.Driver\r\nusername=${env:DATABASE_USERNAME}\r\npassword=${env:DATABASE_PASSWORD}\r\n\r\nconnectionTestQuery=SELECT 1\r\nregisterMbeans=true\r\n\r\n# 15 minutes\r\nmaxLifetime=900000\r\n# 5 minutes\r\nidleTimeout=300000\r\n\r\nmaximumPoolSize=20\r\nminimumIdle=5\r\n```\r\n\r\n## Inspirations and Alternatives\r\n\r\nThe code here is highly inspired by the following plugins:\r\n\r\n1. [swaldman/c3p0-play](https://github.com/swaldman/c3p0-play)\r\n2. [autma/play-hikaricp-plugin](https://github.com/autma/play-hikaricp-plugin)\r\n\r\nWe decide to do our own because both plugins above looks unmaintained.\r\n\r\nThere are also two other alternatives using c3p0:\r\n\r\n1. [hadashi/play2-c3p0-plugin](https://github.com/hadashi/play2-c3p0-plugin)\r\n2. [Furyu/play-c3p0-plugin](https://github.com/Furyu/play-c3p0-plugin)\r\n\r\n## License\r\n\r\nCopyright 2014 Edulify.com\r\n\r\nLicensed under the Apache License, Version 2.0 (the \"License\");\r\nyou may not use this file except in compliance with the License.\r\nYou may obtain a copy of the License at\r\n\r\nhttp://www.apache.org/licenses/LICENSE-2.0\r\n\r\nUnless required by applicable law or agreed to in writing, software\r\ndistributed under the License is distributed on an \"AS IS\" BASIS,\r\nWITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\r\nSee the License for the specific language governing permissions and\r\nlimitations under the License.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}